\chapter{Introduction}
\label{chapter:intro}
\abbrev{PNaCl}{Portable Native Client}
\abbrev{OpenGL}{Open Graphics Library}
\abbrev{WebGL}{Web Graphics Library}
\abbrev{JS}{Javascript}
\abbrev{SIMD}{Single Instruction Multiple Data}
\abbrev{API}{Application Programming Interface}

The scope of the paper is to implement and investigate the potential of implementing a
\project\ using WebGL and web technologies and leveraging them in order to create an efficient game engine.

WebGL is a Khronos specification for the browsers which is modeled after OpenGL ES
2.0. Compared to OpenGL ES 2.0, it lacks some of the commands related to client side
buffers as it is not practical to implement them in JavaScript. The specification also
introduces Typed Arrays to Javascript, as OpenGL needs to have typed data. On Windows,
modern browsers implement WebGL using Angle. Angle is a wrapper for WebGL that
translates all the WebGL calls to DirectX 9.0 and recompiles shaders to HLSL. Because
the use of the WebGL API can’t be trusted (like it’s the case with desktop applications), Angle implement various workarounds for known driver bugs.



\section{Three.js: ups and downs}
\label{sec: ThreeJs}

One of the most popular WebGL libraries is ThreeJS. It’s one of the most used Javascript WebGL libraries on the web and supports multiple renderer backends with fallbacks if the web browser does not support WebGL, to Canvas2D, SVG or CSS3D. 
While it does more than what a renderer should do by providing Scene Management,
Resource Loader, Animation System and different camera types that are integrated in the
input system, it lacks a physics engine, scripting engine, a user accessible input system and a lot more.
A number of libraries based on ThreeJS have appeared that try to fix these problems. For example, Physijs links ThreeJS to ammo.js, an Emscripten compiled Bullet Physics Engine.


\section{Emscripten versus Portable Native Client}
\label{sec: Emscripten, PNaCl}

In 2011, Mozilla introduced Emscripten, a C++ compiler that compiles C++ code to
Javascript, allowing the porting of existing C++ game engines to the web. They also
created asm.js, a typed subset of JavaScript that can be compiled by the JavaScript
interpreter directly to microprocessor instructions. They made it so that Emscripten
generated JavaScript code can get the biggest performance benefit from this. The problem for Emscripten is that if you compile an engine designed for desktop use, you won’t take benefit of the things that the browser offers (like input callbacks, image loading and decompressing, video and audio decompressing and playback capabilities and various other). To fix this problem, Emscripten has it’s own implementation of popular libraries like SDL, glut or glfw that use the browsers native system. Another problem of Emscripten is that JavaScript does not support threads; instead it uses workers. Workers are usually implemented by the interpreter as a separate thread which can communicate only over a message passing API. This means that most of the algorithms implemented in modern engines that use multithreading will not be easily ported and also it introduces a overhead related to the memory copy necessary to transmit the message. The huge advantage is given by asm.js which allows Emscripten compiled C++ code to achieve near native speed performance in your browser. Mozilla, together with Epic, announced that they ported Unreal Engine 4 to the browser, after last year porting the well known Unreal Engine 3 to the browser using emscripten. Unity technologies also announced at GDC that their next Unity Engine will have the ability to export your game to the browser.


A competitive technology pushed by Google in the Chrome web browser is Portable Native
Client (PNaCl) which allows C++ code to be compiled, but not in JavaScript. It compiles
the code using a special compiler to LLVM byte-code and then it’s translated by the
browser to native instructions on the client computer. The code is run in a special PNaCl sandbox and communicates with the browser using a message passing interface similar to that of a worker. It also has access to Pepper Plugin API which allows it to perform OpenGL ES 2.0 and various other actions. PNaCl has all the advantages of running native code, including threading, SIMD operations and memory management. By leveraging these, it is easier to port an existing game to PNaCl than it is to compile it with Emscripten.
One of the downsides is that it doesn’t support linking with dynamic libraries, so all the code needs to be statically linked during linking which may cause licensing issues with some libraries and some of the new WebGL extensions take some time before appearing in the PNaCl API. The major problem with PNaCl is that it is currently only available on Chrome and some other major browsers (Firefox) have already announced that they are not interested in pursuing this path. There are currently only a couple of very successful games ported to PNaCl: one of them is Bastion and the other one is From Dust, from Ubisoft.

Although these approaches have managed to fix the performance issue to some degree,
they have done so by fighting the web technologies with custom APIs and custom
implementations that work only on their browser and have not gained universal
acceptance. This paper proposes to embrace what the web offers and take full advantage
of it, by designing an engine around the APIs offered by a browser instead of trying to fit an existing game engine architecture in the browser.


\section{How does a game engine work?}
\label{sec:game engine}

The main problem in designing an engine in the browser is that you only have one main
loop from which you can call draw orders and that is a slow one. So all the extra
computation necessary like physics and game mechanics need to processed in external
threads and then just sent to the main thread which runs the renderer and the input
system. These are the only modules that need to be run from the main browser thread.
They also need to communicate with other modules using web worker’s message passing
API.

Web workers have a message passing API that allows the programmer to send multiple
JavaScript objects between them and the window. They also implement transferable for
ArrayBuffer objects. When used, the ArrayBuffer objects disappear from one’s scope and
appear in the other place, allowing for very fast memory transfers at about 6GB/s. This
allows texture decompression and scene loading to be done on the workers and then
easily transferred to the main thread.

\subsection{Project Description}
\label{proj-desc}

The game engine’s resource manager will be implemented in a separate web worker and
will handle all the 3D Model Resources, Texture Resources, Material Resources, Font
Resources, Skeleton Resources, Collision Resources, Physics Parameters, Game Map
and many other objects that need loading in order for the scene to run. All the other
workers will communicate with it through messages. An asset pipeline will be created in
order for the Resource Manager to be as efficient as possible, so as not to waste scarce processing power on resource conversion.

The scene will be modeled after a tree structure, each node having it’s own property
modifications that need to be applied on top of the ones in the parent. The nodes will also be able to have a script run after each frame or during a physics sync time. These scripts will be written in Javascript in the form of a function, which receives as parameters the game state, the scene tree and the time from the last callback, it will have to return it’s new node state and any modifications that need to be made to the game state.
It will be tested if it is beneficial to run all the scripts in parallel each in a separate web worker or sequentially in the same state.

The game state is a dictionary, each script registers exclusive access to a number of keys and the other scripts only get a read-only copy of it. After each run, the scripts return the new values for the keys and the game state gets updated. This is one of the ways the game state can be implemented so that it offers non concurrent access to multiple threads that work with it.

The low level renderer will be residing on the main thread and will parse the main scene tree in order to draw the scene. Additional post processing needs to be done with the use of the GPU. For example, the team at Mozilla published an article in which they show how deferred shading can be done with little impact on performance using a new WebGL extensions that requires only two shader passes and doing all the heavy lifting on the GPU. The scene format should be optimized for maximum efficiency, for example objects that are static can be linked into a single mesh and only one draw call performed.
A limit to this strategy is the fact that OpenGL ES 2.0 limits us to 16bit element array indexes, which in turn means that we must make multiple such objects in order to tackle this problem.

The input system is designed around the API’s available to Javascript in a browser. It will be able to use defined actions that can be triggered by a multitude or a combination of key presses or inputs from other devices like mouse, gyroscope or controller. This will allow the game developer to use an abstraction around the key configurations.

Each scene object needs information that can be passed to the physics engine if
necessary. The physics engine that will be used is the popular Bullet Physics Engine,
which is compiled into Javascript using emscripten. There is a Javascript wrapper made
around it, named ammo.js that offers access to all it’s methods. 

The sound manager will use native audio tags in order to deliver the sound effects. It will have to scale the number of sound elements because multiple sounds can be played
simultaneously. Dynamic sound processing is possible using new web audio APIs that
allow the processing of audio streams, either from audio files or from a input source like a microphone.

\subsection{Objective}
\label{sub-sec:proj-desc-objective}

In conclusion the paper aims at trying to engineer a game engine using all the APIs
available in the browser and to make the best use of them.


\section{Summary}
\label{sec:summary}

\labelindexref{Chapter}{chapter:Chapter 2} 

\labelindexref{Chapter}{chapter:Chapter 3} 

\labelindexref{Chapter}{chapter:Chapter 4} 

\labelindexref{Chapter}{chapter:Chapter 5} 

Finally, \labelindexref{Chapter}{chapter:Chapter 6} 
