\chapter{Implementation}
\label{chapter:Chapter 4}

\section{JavaScript Performance}

The first problem in implementing a game engine in JavaScript will be the performance problem caused by the fact that it’s a interpreted and garbage collected language. Modern JavaScript engine implementations try to address this by using a Just in Time (JIT) compiler.

\subsection{Strict mode}

Having a JIT is not enough, as vanilla JavaScript allows you to do a lot of operations which can not be optimized by a JIT, like accessing the callee of a function and its properties. This behavior is not JIT-able as the reference to the callee depends on the context in which the function is called. This made the standardization committee to implement a strict mode in ECMAScript 5. The strict mode is just specifying that the current scope is written in a subset of JavaScript that can be easily compiled and does not have undefined behavior. Strict mode also brings a less error prone coding to JavaScript, one of these features is that variables must be explicitly declared before using them, as opposed to normal JavaScript, when if you use a variable which is not declared it will automatically declare it in the global scope.

\subsection{AsmJS mode}

AsmJS mode is a special mode created by Mozilla and implemented in Firefox. The AsmJS subset of JavaScript can be compiled Ahead of Time (AOT) and it has a stack based memory model. All the variables must be typed. In order for the AsmJS subset to be compatible with engines that don’t know how to interpret it all, the operations that specify type must be no-ops. The only two types supported in AsmJS are “double” and “int”. In order to say that a variable is an “int”, it needs to be bitwise or with 0 (e.g. x = x|0). For “double”, it needs to have a attribution with his sign explicitly defined (e.g. x = +x). This allows for AsmJS to conform to the JavaScript standard.

\subsection{Memory model}

JavaScript is a garbage collected language. All the variables in JavaScript are prototypes which means that they are objects, but for performance reasons various JavaScript engine’s implement Just In Time compilers (JITs) that can compile a certain subset of JavaScript into native code. Some of the JITs have special optimizations for certain variable uses. For example, Chrome’s V8 has optimization for arrays (variables which have the prototype as the Array object), that translates them to normal arrays, but only as long as no other property is attached to it. If this happens, then it falls back to lesser optimized implementations. Arrays by their nature, in JavaScript are just a special case of an object which inherits the Array object. Thus, inherits it’s methods and properties, but each index can also be accessed by referencing to it in a property way (i. e. array.1 instead of array[1]). This coupled together with the fact that you can also access properties through the [] operator (i.e. array[‘length’] instead of array.length), can lead to the creation of sparse arrays. Sparse arrays aren’t optimized in the JIT as demonstrated in V8.(from reference \cite{clifford12})

Another problem that JavaScript poses is the fact that all of it’s arithmetic and numbers are stored on double precision floating point numbers. This makes some of the calculations more slower than expected. It can also introduce type incompatibilities, so in order to interface with WebGL, we need to use TypedArrays. A TypedArray has a backing ArrayBuffer which is a contiguous memory zone. It offers an array like API with a backing store of 8 bit unsigned integers. A TypedArray is just a higher level view of an underlying part of an ArrayBuffer, taking care of implementing arrays of different types over the ArrayBuffer. The types implemented are: Int8Array, Uint8Array, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array. Due to the fact that  JavaScript is still a garbage collected language, this means that although we can allocate these buffers, we can’t also discard of them when they are of no more use.

In Game Engine Architecture \cite{gregory09}, it is presented that most game engines implement their own memory management by preallocating a large buffer and then writing their own allocation routines. One of the simpler routines presented is the stack like allocation, in which a stack pointer is moved with each allocation.

A implementation of a similar allocator in JavaScript can be found in the listing ~\ref{lst:allocation-benchmark}

\lstset{caption=Allocation benchmark (allocator.js), label=lst:allocation-benchmark}
\lstinputlisting{src/listings/allocator.js}

The most called out size for a TypedArray allocation is 16 as this is the size of a 4x4 matrix used for transformations. Another allocation size is around 10000 which can be the average size of a vertex buffer or an index buffer. To top it up, a larger allocation size can be around tens of MB of ram, which can represent textures. I am going to use these three dimensions in a allocation benchmark in order to test how much gain the engine can get from using a custom allocator.

%<insert benchmark here>

As can be seen from the benchmark results, there is no increase in performance by implementing a custom allocator for JavaScript. The only size for which an increase in performance is seen is for a allocation size of 1000. This is quite peculiar, as it would have been expected to see an increase in performance for the case in which a small array is allocated, like for size 16.

\subsection{Speed}

\section{Engine architecture}

The engine is made out of different modules. Each module needs some other modules in order to function. Each of these modules offer an API which they must respect in order for them to function properly, for example the rendering module offers an API which helps rendering. You can replace the rendering module with your own rendering module but you need to respect its API in order for the engine to function. This can be implemented in Java using Interfaces, but since JavaScript doesn’t offer such a feature, nor does it offer a replacement for abstract classes, you can’t force a module to implement an API.

The modules that represent the engine are:

\textbullet Rendering

\textbullet Input Control

\textbullet Resource Manager

\textbullet Camera

\textbullet Physics Engine

\textbullet Scripting

\textbullet Timer

\section{Asset Pipeline}

In order to import assets into a game engine, all the major engines require an asset pipeline that pre-processes assets. This engine is not different from the others. Because asset importing takes a lot of parsing and processing, it is best to be done offline. In the engine, the asset pipeline consists in using assimp2json in order to convert the files to the same format. If there are more modifications needed to be done on the file, then the file can be modified using a simple text editor. All the assets are grouped in zip files. Each corresponding zip file corresponds to a portion of game data that must be loaded at runtime all at once, like all the data necessary for a game level. It must also contain a manifest file. This manifest file specifies options regarding the loaded data file like: paths or various types of files, the main scene file to load. These are specified in a file named manifest.json.

\section{Resource Manager}

The resource manager takes care of downloading and storing the resources. It uses zipjs in ordered to read the data files. Zipjs offers a virtual filesystem that can be used in order to load files from the game data archive.
The resource manager is responsible for loading the data and the scene from the file system. It parses the scene files and creates scene objects from them. It does a preloading of all the scenes in the file, so that if a scene references another scene inside itself it should be already loaded. It also handles texture loading from files and replaces them with image objects which can be used to load textures onto objects.

\section{Rendering Engine}

\section{Input Control}

The input control system handles all the bindings to the DOM events. It then forwards the events to the current inputcontrol object. 
Each InputControl object holds an ArrayBuffer which contains the state of the keys. The input control is based on actions, each action is defined by a set of keys which can trigger it. The set of keys is defined as a string representing them. Each of these keys pressed is enough to consider the action to be true. One of this sets is named an action. In order to check if an action is true, the API offers an action method which needs to be called using the name of the action. There can be multiple input controls defined, but only one active at a certain time. Activating an input control is done by using the useInputControl method. 

HTML5 had an API which allows mouse locking to occur, named PointerLock API. Each time we request a pointer lock, this triggers a visual confirmation prompt to the user who must allow or deny the pointer lock. This is different from the usual desktop implementation which doesn't require confirmation from the user in order to lock the mouse pointer.
The API also offers the possibility to receive mouse moves as a delta from the last mouse move event. The drawback of using this API is that it binds the ESC key to itself in order to allow the user to exit the mouse lock. 


\section{Camera}

The camera system handles the view and projection matrices. Each camera must implement its own way of handling these. Each camera is also offered access to the input system in order for camera movement to be possible. 
The implemented camera is a orbiting perspective camera. It hold its angle in a quaternion. This is done in order to maintain the possibility of doing affine transformations on the camera position and rotation. The camera is responsible for updating the renderer’s view and projection matrices.


\section{Physics Engine}

The physics engine is just a wrapper over Ammo.JS

\section{Scripting}

The scripting system is based upon the fact that JavaScript is an interpreted language. All the scripts are wrapped in a javascript scope, where a couple of objects are made available. The scope is created by inserting the javascript code into a function body. This can be done because in JavaScript functions are first-class citizens, this means that functions can be manipulated however the programmer wants. Of course this does not allow the JIT to compile something that might modify itself, so under strict mode only the creation of new functions is possible. This can be done using the Function prototype.
The only problem with this model is that inclusion of other scripts is not possible, which lead to including a lot of objects into the scope of the script.
These objects are:

\textbullet Scene graph - the current scene graph object is included in order for the script to be able to manipulate the scene’s objects. This scene graph also contains the physics objects used to calculate the object’s physics.

\textbullet Global storage - an object which can be used by the scripts in order to be able to store data between executions.

\textbullet Resource manager - the resource manager is present here in order to be able to load different scenes or different game data files, like for example a new level.

\textbullet Math helper classes - classes like mat4, vec3 and all the other classes that the gl-matrix library offers are passed into the scope in order for scripts to be able to do mathematical operations easier

\textbullet Timer system

You might notice that no persistent storage is offered. This is done because the scripts already have access to persistent storage by using the normal browser API’s like IndexedDB or LocalStorage. These should be sufficient for all the script’s needs.
Due to the fact that JavaScript is run on a single thread it is possible for scripts to run for a longer duration without the possibility to stop their execution. This can be solved by executing them in a SharedWorker, but this means that all these objects need to be passed each time the script is executed, which might have a negative impact on the engine’s performance.
Another popular scripting language is Lua. Lua can be run from JavaScript using Moonshine, a Lua VM written in JavaScript. 
C++ scripting can also be integrated by compiling the scripts using Emscripten, but because of Emscripten’s bootstrapping for each C++ code, it is probably not preferred.

\section{Timer}

The timer module is a utility module that gives the programmer all the timing option he needs. In order to offer high precision timing, the timer module uses the high precision time function: window.performance.now(). This function is useful for implementing high resolution timers.
The most basic timers are profiling timers, these are used to track and aggregate stats regarding a certain operation that the programmer wants profiled. It keeps track of subsequent invocations of the same timer id and generates the minimum time interval, the maximum time interval and the average time interval for each timing. It can print a report of all the timers. You can use the profiling feature by calling the start and stop methods of the Timer class. These methods take a single parameter: the id of the profiled section. The id should be mapped to a name using the map method; this ensures that the timer is presented in the statistics.

Another type of timers are real time timers, these timers track the time passing in real time. They are useful for interpolating animations and various other effects. These timers are instanced based. They are obtained by instantiating a RealTimeTimer object.

The last type of timers are discrete timers. Discrete timers are obtained by calling the getTimer method of a DiscreteTimeClock. The discrete timer measures the time passed from the creation of the object to the current time of the discrete clock it’s associated with.

