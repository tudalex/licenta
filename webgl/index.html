<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title> Turtle Engine </title>
</head>
<body >

    <canvas width="640px" height="480px" id="test"></canvas>
    <script id="shader-fs" type="x-shader/x-fragment">
        #extension  GL_EXT_draw_buffers : require
        precision highp float;
        varying vec2 vTextureCoord;
        varying float fs_Depth;
        uniform sampler2D uSampler;

        varying vec3 fs_Normal;

        vec4 packFloatToVec4 (const float value) {
            vec4 bitSh = vec4 ( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0);
            vec4 bitMask = vec4(0.0, 1.0/256.0, 1.0/256.0, 1.0/256.0);
            vec4 res = fract(value * bitSh);
            res -= res.xxyz * bitMask;
            return res;
        }

        struct material {
            vec4 ambient;
            vec4 diffuse;
            vec4 emissive;
            vec4 reflective;
            vec4 specular;
            vec4 transparent;
        };
        uniform material materials[32];
        uniform int materialindex;
        void main(void) {
            //gl_FragColor = texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t));vec4(1.0,1.0, 1.0, 1.0);
            gl_FragData[0] = vec4(1.0, 1.0, 1.0, 1.0);
            gl_FragData[1] = packFloatToVec4(fs_Depth);
            gl_FragData[2] = vec4(fs_Normal.xyz, 1.0);
        }
    </script>
    <script id="shader-vs" type="x-shader/x-vertex">
      precision highp float;
      attribute vec3 aVertexPosition;
      attribute vec2 aTextureCoord;
      attribute vec3 aNormal;

      uniform mat4 uMVMatrix;
      uniform mat4 uPMatrix;
      uniform mat4 uLookAt;


      varying vec2 vTextureCoord;
      varying vec3 fs_Normal;

      varying float fs_Depth;

      void main(void) {
        gl_Position = uPMatrix  * uLookAt * uMVMatrix * vec4(aVertexPosition, 1.0);
        fs_Depth = ((gl_Position.z / gl_Position.w));
        vTextureCoord = aTextureCoord;
        fs_Normal = ( uMVMatrix * uLookAt * vec4(aNormal, 0.0)).xyz;
      }
    </script>
    <script id="last-fs" type="x-shader/x-fragment">
        precision highp float;
        varying vec2 vTextureCoord;

        uniform sampler2D uSampler0;
        uniform sampler2D uSampler1;
        uniform sampler2D uSampler2;
        uniform sampler2D uSampler3;
        uniform vec2 resolution;

        #define FXAA_REDUCE_MIN   (1.0/ 128.0)
        #define FXAA_REDUCE_MUL   (1.0 / 8.0)
        #define FXAA_SPAN_MAX     8.0

        vec4 applyFXAA(vec2 fragCoord, sampler2D tex)
        {
            vec4 color;
            vec2 inverseVP = vec2(1.0 / resolution.x, 1.0 / resolution.y);
            vec3 rgbNW = texture2D(tex, (fragCoord + vec2(-1.0, -1.0)) * inverseVP).xyz;
            vec3 rgbNE = texture2D(tex, (fragCoord + vec2(1.0, -1.0)) * inverseVP).xyz;
            vec3 rgbSW = texture2D(tex, (fragCoord + vec2(-1.0, 1.0)) * inverseVP).xyz;
            vec3 rgbSE = texture2D(tex, (fragCoord + vec2(1.0, 1.0)) * inverseVP).xyz;
            vec3 rgbM  = texture2D(tex, fragCoord  * inverseVP).xyz;
            vec3 luma = vec3(0.299, 0.587, 0.114);
            float lumaNW = dot(rgbNW, luma);
            float lumaNE = dot(rgbNE, luma);
            float lumaSW = dot(rgbSW, luma);
            float lumaSE = dot(rgbSE, luma);
            float lumaM  = dot(rgbM,  luma);
            float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));
            float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));

            vec2 dir;
            dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));
            dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));

            float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) *
                                  (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);

            float rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);
            dir = min(vec2(FXAA_SPAN_MAX, FXAA_SPAN_MAX),
                      max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),
                      dir * rcpDirMin)) * inverseVP;

            vec3 rgbA = 0.5 * (
                texture2D(tex, fragCoord * inverseVP + dir * (1.0 / 3.0 - 0.5)).xyz +
                texture2D(tex, fragCoord * inverseVP + dir * (2.0 / 3.0 - 0.5)).xyz);
            vec3 rgbB = rgbA * 0.5 + 0.25 * (
                texture2D(tex, fragCoord * inverseVP + dir * -0.5).xyz +
                texture2D(tex, fragCoord * inverseVP + dir * 0.5).xyz);

            float lumaB = dot(rgbB, luma);
            if ((lumaB < lumaMin) || (lumaB > lumaMax))
                color = vec4(rgbA, 1.0);
            else
                color = vec4(rgbB, 1.0);
            return color;
        }

        float unpackFloatFromVec4 (const vec4 value) {
            const vec4 bitSh = vec4(1.0/ (256.0 * 256.0 * 256.0), 1.0/(256.0 * 256.0), 1.0/256.0, 1.0);
            return dot(value, bitSh);
        }

        uniform vec3 lightPos;


        void main(void) {
            float d =  pow(texture2D(uSampler1, gl_FragCoord.xy/resolution).x, 255.0);
            //gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);
            gl_FragColor = vec4(d, d, d, 1.0);
            gl_FragColor = vec4(texture2D(uSampler3, gl_FragCoord.xy/resolution));
            gl_FragColor = applyFXAA(gl_FragCoord.xy, uSampler3);
        }
    </script>
    <script id="last-vs" type="x-shader/x-vertex">
      attribute vec3 aVertexPosition;
      attribute vec2 aTextureCoord;

      uniform mat4 uMVMatrix;
      uniform mat4 uPMatrix;
      uniform mat4 uLookAt;

      varying vec2 vTextureCoord;

      void main(void) {
        gl_Position = vec4(aVertexPosition, 1.0);
        vTextureCoord = aTextureCoord;
      }
    </script>

    <script src="js/vendor/stats.min.js"></script>
    <!--<script src="js/vendor/webgl-debug.js"></script>-->
    <script src="js/vendor/gl-matrix.js"></script>
    <script src="js/engine/resource.js"></script>
    <script src="js/engine/camera.js"></script>
    <script src="js/engine/renderer.js"></script>
    <script src="js/engine/input.js"></script>
    <script src="js/engine/engine.js"></script>
<script>
var engine = new Engine("test");
engine.loadScene('teapots.dae.json');


</script>


</body>
</html>
