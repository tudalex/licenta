<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title> Turtle Engine </title>
</head>
<body >

    <canvas width="512px" height="512px" id="test"></canvas>
    <script id="shader-fs" type="x-shader/x-fragment">
        #extension  GL_EXT_draw_buffers : require
        precision highp float;
        varying vec2 vTextureCoord;
        varying float fs_Depth;
        uniform sampler2D uSampler;

        varying vec3 fs_Normal;
        varying vec4 fs_WorldPos;

        vec4 packFloatToVec4 (const float value) {
            vec4 bitSh = vec4 ( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0);
            vec4 bitMask = vec4(0.0, 1.0/256.0, 1.0/256.0, 1.0/256.0);
            vec4 res = fract(value * bitSh);
            res -= res.xxyz * bitMask;
            return res;
        }
        vec2 pack2(float val) {
            vec2 pack = vec2(1.0, 255.0) * val;
            pack = fract(pack);
            pack -= vec2(pack.y / 255.0, 0.0);
            return pack;
        }
        vec4 encode(vec3 n) {
            vec2 enc  = normalize(n.xy) * (sqrt(-n.z*0.5 + 0.5));
            enc = enc *0.5 + 0.5;
            vec4 ret;
            ret.xy = pack2(enc.x);
            ret.zw = pack2(enc.y);
            return ret;
        }
        struct material {
            vec4 ambient;
            vec4 diffuse;
            vec4 emissive;
            vec4 reflective;
            vec4 specular;
            vec4 transparent;
        };
        uniform material materials[32];
        uniform int materialindex;
        void main(void) {
            //fs_Normal = normalize(fs_Normal);
            //gl_FragColor = texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t));vec4(1.0,1.0, 1.0, 1.0);
            gl_FragData[0] = vec4(1.0, 1.0, 1.0, 1.0);
            gl_FragData[1] = packFloatToVec4(fs_Depth);
            gl_FragData[2] = encode(fs_Normal);
            gl_FragData[3] = fs_WorldPos;
            //gl_FragData[2] = vec4(fs_Normal, 1.0);
        }
    </script>
    <script id="shader-vs" type="x-shader/x-vertex">
      precision highp float;
      attribute vec3 aVertexPosition;
      attribute vec2 aTextureCoord;
      attribute vec3 aNormal;

      uniform mat4 uMVMatrix;
      uniform mat4 uPMatrix;
      uniform mat4 uLookAt;


      varying vec2 vTextureCoord;
      varying vec3 fs_Normal;
      varying vec4 fs_WorldPos;

      varying float fs_Depth;

      void main(void) {
        fs_WorldPos = uMVMatrix * vec4(aVertexPosition, 1.0);
        gl_Position = uPMatrix  * uLookAt * fs_WorldPos;
        fs_Depth = ((gl_Position.z / gl_Position.w));
        vTextureCoord = aTextureCoord;
        fs_Normal = ( uMVMatrix * uLookAt * vec4(aNormal, 0.0)).xyz;
        fs_Normal = normalize(fs_Normal);

      }
    </script>
    <script id="last-fs" type="x-shader/x-fragment">
        precision highp float;
        varying vec2 vTextureCoord;

        uniform sampler2D uSampler0;
        uniform sampler2D uSampler1;
        uniform sampler2D uSampler2;
        uniform sampler2D uSampler3;
        uniform vec2 resolution;


        vec4 packFloatToVec4 (const float value) {
            vec4 bitSh = vec4 ( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0);
            vec4 bitMask = vec4(0.0, 1.0/256.0, 1.0/256.0, 1.0/256.0);
            vec4 res = fract(value * bitSh);
            res -= res.xxyz * bitMask;
            return res;
        }

        #define FXAA_REDUCE_MIN   (1.0/ 128.0)
        #define FXAA_REDUCE_MUL   (1.0 / 8.0)
        #define FXAA_SPAN_MAX     8.0

        vec4 applyFXAA(vec2 fragCoord, sampler2D tex) {
            vec4 color;
            vec2 inverseVP = vec2(1.0 / resolution.x, 1.0 / resolution.y);
            vec3 rgbNW = texture2D(tex, (fragCoord + vec2(-1.0, -1.0)) * inverseVP).xyz;
            vec3 rgbNE = texture2D(tex, (fragCoord + vec2(1.0, -1.0)) * inverseVP).xyz;
            vec3 rgbSW = texture2D(tex, (fragCoord + vec2(-1.0, 1.0)) * inverseVP).xyz;
            vec3 rgbSE = texture2D(tex, (fragCoord + vec2(1.0, 1.0)) * inverseVP).xyz;
            vec3 rgbM  = texture2D(tex, fragCoord  * inverseVP).xyz;
            vec3 luma = vec3(0.299, 0.587, 0.114);
            float lumaNW = dot(rgbNW, luma);
            float lumaNE = dot(rgbNE, luma);
            float lumaSW = dot(rgbSW, luma);
            float lumaSE = dot(rgbSE, luma);
            float lumaM  = dot(rgbM,  luma);
            float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));
            float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));

            vec2 dir;
            dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));
            dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));

            float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) *
                                  (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);

            float rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);
            dir = min(vec2(FXAA_SPAN_MAX, FXAA_SPAN_MAX),
                      max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),
                      dir * rcpDirMin)) * inverseVP;

            vec3 rgbA = 0.5 * (
                texture2D(tex, fragCoord * inverseVP + dir * (1.0 / 3.0 - 0.5)).xyz +
                texture2D(tex, fragCoord * inverseVP + dir * (2.0 / 3.0 - 0.5)).xyz);
            vec3 rgbB = rgbA * 0.5 + 0.25 * (
                texture2D(tex, fragCoord * inverseVP + dir * -0.5).xyz +
                texture2D(tex, fragCoord * inverseVP + dir * 0.5).xyz);

            float lumaB = dot(rgbB, luma);
            if ((lumaB < lumaMin) || (lumaB > lumaMax))
                color = vec4(rgbA, 1.0);
            else
                color = vec4(rgbB, 1.0);
            return color;
        }

        float unpackFloatFromVec4 (const vec4 value) {
            const vec4 bitSh = vec4(1.0/ (256.0 * 256.0 * 256.0), 1.0/(256.0 * 256.0), 1.0/256.0, 1.0);
            return dot(value, bitSh);
        }

        float unpack2(const vec2 pack) {
            return dot(pack, vec2(1.0, 1.0 / 255.0));
        }

        vec3 decode(vec4 enc) {
            vec4 nn = enc* vec4(2, 2, 0, 0) + vec4( -1, -1, 1, -1);
            float l = dot(nn.xyz, -nn.xyw);
            nn.z = l;
            nn.xy *= sqrt(l);
            return nn.xyz * 2.0 + vec3(0, 0, -1);
        }

        uniform vec3 lightPos;
        const float zNear = 0.1;
        const float zFar = 10000.0;

        void main(void) {
            float d =  pow(texture2D(uSampler1, gl_FragCoord.xy / resolution).x, 255.0);
            float z_b = texture2D(uSampler1, gl_FragCoord.xy / resolution).x;
            float z_n = 2.0 * z_b - 1.0;
            float z_e = 2.0 * zNear * zFar / (zFar + zNear - z_b * (zFar - zNear));
            d = z_e;

            //gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);
            //gl_FragColor = vec4(d, d, d, 1.0);
            //gl_FragColor = vec4(packFloatToVec4(d).xyz, 1.0);
            vec4 normalTex = vec4(texture2D(uSampler3, gl_FragCoord.xy / resolution));
            vec3 normal = decode(vec4(unpack2(normalTex.xy), unpack2(normalTex.zw), 0, 0));
            gl_FragColor = vec4(normal, 1.0);

            //gl_FragColor = applwyFXAA(gl_FragCoord.xy, uSampler3);
        }
    </script>
    <script id="last-vs" type="x-shader/x-vertex">
      precision highp float;
      attribute vec3 aVertexPosition;
      attribute vec2 aTextureCoord;
      attribute vec3 aNormal;

      uniform mat4 uMVMatrix;
      uniform mat4 uPMatrix;
      uniform mat4 uLookAt;


      varying vec2 vTextureCoord;
      varying vec3 vNormal;

      void main(void) {
        gl_Position = vec4(aVertexPosition, 1.0);
        vTextureCoord = aTextureCoord;
        vNormal = aNormal;
      }
    </script>
    <!-- Vendor -->
    <script type="application/javascript" src="js/vendor/ammo.js"></script>
    <script type="application/javascript" src="js/vendor/stats.min.js"></script>
    <script type="application/javascript" src="js/vendor/jszip.js"></script>
    <script src="js/vendor/webgl-debug.js"></script>
    <script type="application/javascript" src="js/vendor/gl-matrix.js"></script>

    <!-- Engine -->
    <script type="application/javascript" src="js/engine/timer.js"></script>
    <script type="application/javascript" src="js/engine/physics.js"></script>
    <script type="application/javascript" src="js/engine/resource.js"></script>
    <script type="application/javascript" src="js/engine/camera.js"></script>
    <script type="application/javascript" src="js/engine/renderer.js"></script>
    <script type="application/javascript" src="js/engine/input.js"></script>
    <script type="application/javascript" src="js/engine/engine.js"></script>
<script type="application/javascript">

var engine = new Engine("test");
engine.loadGameData("webgl.zip");


</script>


</body>
</html>
